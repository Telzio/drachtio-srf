<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>dialog.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Dialog.html">Dialog</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Dialog.html#destroy">destroy</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Dialog.html#modify">modify</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Dialog.html#request">request</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Srf.html">Srf</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Srf.html#connect">connect</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Srf.html#createB2BUA">createB2BUA</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Srf.html#createBackToBackDialogs">createBackToBackDialogs</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Srf.html#createUAC">createUAC</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Srf.html#createUacDialog">createUacDialog</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Srf.html#createUAS">createUAS</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Srf.html#createUasDialog">createUasDialog</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Srf.html#proxyRequest">proxyRequest</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Srf.html#request">request</a></span></li><li class="nav-heading">Events</li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="Dialog.html#event:destroy">destroy</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="Dialog.html#event:info">info</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="Dialog.html#event:modify">modify</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="Dialog.html#event:notify">notify</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="Dialog.html#event:refer">refer</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="Dialog.html#event:refresh">refresh</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="Dialog.html#event:update">update</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="Srf.html#event:cdr:attempt">cdr:attempt</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="Srf.html#event:cdr:start">cdr:start</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="Srf.html#event:cdr:stop">cdr:stop</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="Srf.html#event:connect">connect</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li>
</nav>

<div id="main">
    
    <h1 class="page-title">dialog.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Emitter = require('events').EventEmitter ;
const assert = require('assert') ;
const noop = require('node-noop').noop;
const only = require('only') ;
const methods = require('sip-methods') ;
const debug = require('debug')('drachtio-srf') ;

/**
 * Arguments provided to Dialog constructor.
 * @typedef {Object} Dialog~Options
 * @property {Object} req drachtio Request (only provided when creating a 'uas' dialogs)
 * @property {Object} res drachtio Response
 * @property {Object} [sent] - uas only: actual Response sent when confirming the dialog
 */

/**
 * SIP Dialog.
 * &lt;br>Note: rather than calling the Dialog constructor directly, Dialogs should be created
 * by calling {@link Srf#createUacDialog}, {@link Srf#createUasDialog}, or {@link Srf#createBackToBackDialogs}.
 * @constructor
 * @param {Srf} srf - Srf instance that created this dialog
 * @param {string} type - type of SIP dialog: 'uac', or 'uas'
 * @param {Dialog~Options} opts
 */
class Dialog extends Emitter {

  constructor(srf, type, opts) {
    super() ;

    const types = ['uas', 'uac'] ;
    assert.ok(-1 !== types.indexOf(type), 'argument \'type\' must be one of ' + types.join(',')) ;

    this.srf = srf ;
    this.type = type ;
    this.req = opts.req ;
    this.res = opts.res ;
    this.agent = this.res.agent ;
    this.onHold = false ;
    this.connected = true ;

    /**
     * sip properties that uniquely identify this Dialog
     * @type {Dialog~SipInfo}
     */
    this.sip = {
      callId: this.res.get('Call-ID'),
      remoteTag: 'uas' === type ?
        this.req.getParsedHeader('from').params.tag : this.res.getParsedHeader('to').params.tag,
      localTag: 'uas' === type ?
        opts.sent.getParsedHeader('to').params.tag : this.req.getParsedHeader('from').params.tag
    } ;

    /**
     * local side of the Dialog
     * @type {Dialog~SipEndpointInfo}
     */
    this.local = {
      uri: 'uas' === type ? opts.sent.getParsedHeader('Contact')[0].uri : this.req.uri,
      sdp: 'uas' === type ? opts.sent.body : this.req.body,
      contact: 'uas' === type ? opts.sent.get('Contact') : this.req.get('Contact')
    } ;

    /**
     * local side of the Dialog
     * @type {Dialog~SipEndpointInfo}
     */
    this.remote = {
      uri: 'uas' === type ? this.req.getParsedHeader('Contact')[0].uri : this.res.getParsedHeader('Contact')[0].uri,
      sdp: 'uas' === type ? this.req.body : this.res.body
    } ;
  }

  get id() {
    return this.res.stackDialogId ;
  }

  get dialogType() {
    return this.req.method ;
  }

  get subscribeEvent() {
    return this.dialogType === 'SUBSCRIBE' ? this.req.get('Event') : null ;
  }

  toJSON() {
    return only(this, 'id type sip local remote onHold') ;
  }

  toString() {
    return this.toJSON().toString() ;
  }

  /**
   * destroy the sip dialog by generating a BYE request (in the case of INVITE dialog),
   * or NOTIFY (in the case of SUBSCRIBE)
   * @param {Dialog~requestCallback=} cb callback that returns the generated BYE message
   */
  destroy(opts, cb) {
    opts = opts || {} ;
    cb = cb || noop ;
    if (typeof opts === 'function') {
      cb = opts ;
      opts = {} ;
    }

    if (this.dialogType === 'INVITE') {
      this.agent.request({
        method: 'BYE',
        headers: opts.headers || {},
        stackDialogId: this.id,
        _socket: this.req._socket
      }, (err, bye) => {
        this.connected = false ;
        this.srf.removeDialog(this) ;
        cb(err, bye) ;
      }) ;
    }
    else if (this.dialogType === 'SUBSCRIBE') {
      opts.headers = opts.headers || {} ;
      opts.headers['subscription-state'] = 'terminated';
      opts.headers['event'] = this.subscribeEvent ;
      this.agent.request({
        method: 'NOTIFY',
        headers: opts.headers || {},
        stackDialogId: this.id,
        _socket: this.req._socket
      }, (err, notify) => {
        this.connected = false ;
        this.srf.removeDialog(this) ;
        cb(err, notify) ;
      }) ;
    }
  }

  /**
   * modify the dialog session by changing attributes of the media connection
   * @param  {string} sdp - 'hold', 'unhold', or a session description protocol
   * @param  {Dialog~modifySessionCallback} [cb] - callback invoked when operation has completed
   */
  modify(sdp, cb) {
    cb = cb || noop ;

    switch (sdp) {
      case 'hold':
        this.local.sdp = this.local.sdp.replace(/a=sendrecv/, 'a=inactive') ;
        this.onHold = true ;
        break ;
      case 'unhold':
        if (this.onHold) {
          this.local.sdp = this.local.sdp.replace(/a=inactive/, 'a=sendrecv') ;
        }
        else {
          console.error('Dialog#modify: attempt to \'unhold\' session which is not on hold');
          return process.nextTick(() => {
            cb(new Error('attempt to unhold session that is not on hold'));
          }) ;
        }
        break ;
      default:
        this.local.sdp = sdp ;
        break ;
    }

    debug('Dialog#modify: sending reINVITE for dialog id: %s, sdp: ', this.id, this.local.sdp) ;
    this.agent.request({
      method: 'INVITE',
      stackDialogId: this.id,
      body: this.local.sdp,
      _socket: this.req._socket,
      headers: {
        'Contact': this.local.contact
      }
    }, (err, req) => {
      req.on('response', (res, ack) => {
        debug('Dialog#modifySession: received response to reINVITE with status %d', res.status) ;
        if (res.status >= 200) {
          ack() ;
          if (200 === res.status) {
            this.remote.sdp = res.body ;
            return cb(null);
          }
          cb(new Error('' + res.status + ' ' + res.reason, 'E_SIP' + res.status)) ;
        }
      }) ;
    }) ;
  }

  /**
   * send a request within a dialog.
   * Note that you may also call &lt;code>request.info(..)&lt;/code> as a shortcut
   * to send an INFO message, &lt;code>request.notify(..)&lt;/code>
   * to send a NOTIFY, etc..
   * @param  {Dialog~requestOptions}   opts - configuration options
   * @param  {Dialog~requestCallback} [cb]  - callback invoked when operation has completed
   */
  request(opts, cb) {
    assert.ok(typeof opts.method === 'string' &amp;&amp;
      -1 !== methods.indexOf(opts.method), '\'opts.method\' is required and must be a SIP method') ;

    var method = opts.method.toUpperCase() ;
    cb = cb || noop ;

    this.agent.request({
      method: method,
      stackDialogId: this.id,
      headers: opts.headers || {},
      _socket: this.req._socket,
      body: opts.body
    }, (err, req) => {
      if (err) {
        return cb(err) ;
      }

      req.on('response', (res, ack) => {
        if ('BYE' === method) {
          this.srf.removeDialog(this) ;
        }
        if (res.status >= 200) {
          if ('INVITE' === method) { ack() ; }

          if (this.dialogType === 'SUBSCRIBE' &amp;&amp; 'NOTIFY' === method &amp;&amp;
            /terminated/.test(req.get('Subscription-State'))) {
            debug('received a 200 OK to a NOTIFY we sent with Subscription-State terminated; dialog is ended') ;
            this.connected = false ;
            this.srf.removeDialog(this) ;
            this.emit('destroy', req.msg) ;
          }

          cb(null, res) ;
        }
      }) ;
    }) ;
  }

  handle(req, res) {
    debug('Dialog handling message: ', req.method) ;
    var eventName = req.method.toLowerCase() ;
    switch (req.method) {
      case 'BYE':
        this.connected = false ;
        this.srf.removeDialog(this) ;
        res.send(200) ;
        this.emit('destroy', req.msg) ;
        break ;

      case 'INVITE':
        var origRedacted = this.remote.sdp.replace(/^o=.*$/m, 'o=REDACTED') ;
        var newRedacted = req.body.replace(/^o=.*$/m, 'o=REDACTED') ;
        var refresh = req.body === this.remote.sdp ;
        var hold = origRedacted.replace(/a=sendrecv\r\n/g, 'a=sendonly\r\n') === newRedacted ;
        var unhold = origRedacted.replace(/a=sendonly\r\n/g, 'a=sendrecv\r\n') === newRedacted ;
        var modify = !hold &amp;&amp; !unhold &amp;&amp; !refresh ;
        this.remote.sdp = req.body ;

        if (refresh) {
          this.emit('refresh', req.msg);
        }
        else if (hold) {
          this.local.sdp = this.local.sdp.replace(/a=sendrecv\r\n/g, 'a=recvonly\r\n') ;
          this.emit('hold', req.msg) ;
        }
        else if (unhold) {
          this.local.sdp = this.local.sdp.replace(/a=recvonly\r\n/g, 'a=sendrecv\r\n') ;
          this.emit('unhold', req.msg) ;
        }
        if ((refresh || hold || unhold) || (modify &amp;&amp; 0 === this.listeners('modify').length)) {
          debug('responding with 200 OK to reINVITE') ;
          res.send(200, {
            body: this.local.sdp,
            headers: {
              'Contact': this.local.contact,
              'Content-Type': 'application/sdp'
            }
          }) ;
        }
        else if (modify) {
          this.emit('modify', req, res) ;
        }
        break ;

      case 'NOTIFY':
        // if this is a subscribe dialog and subscription-state: terminated, then destroy the dialog
        if (req.has('subscription-state') &amp;&amp; /terminated/.test(req.get('subscription-state'))) {
          setImmediate(() => {
            debug('received a NOTIFY with Subscription-State terminated; dialog is ended') ;
            this.connected = false ;
            this.srf.removeDialog(this) ;
            this.emit('destroy', req.msg) ;
          }) ;
        }
        if (0 === this.listeners(eventName).length) {
          res.send(200) ;
        }
        else {
          this.emit(eventName, req, res) ;
        }
        break ;

      case 'SUBSCRIBE':
      case 'INFO':
      case 'REFER':
      case 'OPTIONS':
      case 'UPDATE':
        if (0 === this.listeners(eventName).length) {
          res.send(200) ;
        }
        else {
          this.emit(eventName, req, res) ;
        }
        break ;

      case 'ACK':
        this.emit('ack', req.msg) ;
        break ;

      default:
        console.error('Dialog#handle received invalid method within an INVITE dialog: %s', req.method) ;
        res.send(501) ;
        break ;
    }

  }
}

module.exports = exports = Dialog ;

methods.forEach((method) => {
  Dialog.prototype[method.toLowerCase()] = (opts, cb) => {
    opts = opts || {} ;
    opts.method = method ;
    return this.request(opts, cb) ;
  };
}) ;


/**
 * @typedef {Object} Dialog~requestOptions
 * @property {String} method - SIP method to use for the request
 * @property {Object} [headers] - SIP headers to apply to the request
 * @property {String} [body] - body of the SIP request
 */
/**
 * This callback provides the response to a sip request sent within the dialog.
 * @callback Dialog~requestCallback
 * @param {Error} err - error, if any
 * @param {Response} response -  response received from the far end
 */


/**
 * This callback provides the SIP request that was generated
 * @callback Dialog~requestCallback
 * @param {Error} err   error returned on non-success
 * @param {Request} req Request that was generated
 */


/**
 * This callback provides the response a modifySession request.
 * @callback Dialog~modifySessionCallback
 * @param {Error} err  non-success sip response code received from far end
 */


/**
 * SIP Dialog identifiers
 * @typedef {Object} Dialog~SipInfo
 * @property {String} callId - SIP Call-ID
 * @property {String} localTag - tag generated by local side of the Dialog
 * @property {String} remoteTag  - tag generated by the remote side of the Dialog
 */
/**
 * SIP Endpoint identifiers
 * @typedef {Object} Dialog~SipEndpointInfo
 * @property {String} uri - sip
 * @property {String} sdp - session description protocol
 */
/**
 * a &lt;code>destroy&lt;/code> event is triggered when the Dialog is torn down from the far end
 * @event Dialog#destroy
 * @param {Object} msg - incoming BYE request message
 */
/**
 * a &lt;code>modify&lt;/code> event is triggered when the far end modifies the session by sending a re-INVITE.
 * When an application adds a handler for this event it must generate
 * the SIP response by calling &lt;code>res.send&lt;/code> on the provided drachtio response object.
 * When no handler is found for this event a 200 OK with the current local SDP
 * will be automatically generated.
 * @event Dialog#modify
 * @param {Object} req - drachtio request object
 * @param {Object} res - drachtio response object
 */
/**
 * a &lt;code>refresh&lt;/code> event is triggered when the far end sends a session refresh.
 * There is no need for the application to respond to this event; this is purely
 * a notification.
 * @event Dialog#refresh
 * @param {Object} msg - incoming re-INVITE request message
 */
/**
 * an &lt;code>info&lt;/code> event is triggered when the far end sends an INFO message.
 * When an application adds a handler for this event it must generate
 * the SIP response by calling &lt;code>res.send&lt;/code> on the provided drachtio response object.
 * When no handler is found for this event a 200 OK will be automatically generated.
 * @event Dialog#info
 * @param {Object} req - drachtio request object
 * @param {Object} res - drachtio response object
 */
/**
 * a &lt;code>notify&lt;/code> event is triggered when the far end sends a NOTIFY message.
 * When an application adds a handler for this event it must generate
 * the SIP response by calling &lt;code>res.send&lt;/code> on the provided drachtio response object.
 * When no handler is found for this event a 200 OK will be automatically generated.
 * @event Dialog#notify
 * @param {Object} req - drachtio request object
 * @param {Object} res - drachtio response object
 */
/**
 * an &lt;code>update&lt;/code> event is triggered when the far end sends an UPDATE message.
 * When an application adds a handler for this event it must generate
 * the SIP response by calling &lt;code>res.send&lt;/code> on the provided drachtio response object.
 * When no handler is found for this event a 200 OK will be automatically generated.
 * @event Dialog#update
 * @param {Object} req - drachtio request object
 * @param {Object} res - drachtio response object
 */
/**
 * a &lt;code>refer&lt;/code> event is triggered when the far end sends a REFER message.
 * When an application adds a handler for this event it must generate
 * the SIP response by calling &lt;code>res.send&lt;/code> on the provided drachtio response object.
 * When no handler is found for this event a 200 OK will be automatically generated.
 * @event Dialog#refer
 * @param {Object} req - drachtio request object
 * @param {Object} res - drachtio response object
 */

</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.4</a> on Thu Nov 23 2017 15:09:15 GMT-0600 (CST) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
